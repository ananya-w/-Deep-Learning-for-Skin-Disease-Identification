# -*- coding: utf-8 -*-
"""skin disease .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oeQy9wvYjKlapGq8-ujvk3uSXUTechJQ
"""

!pip install -q kaggle

from google.colab import files
files.upload()

!mkdir ~/.kaggle

!cp kaggle.json ~/.kaggle/

!chmod 600 ~/.kaggle/kaggle.json

!kaggle datasets download subirbiswas19/skin-disease-dataset

!unzip \*.zip

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import pandas as pd
import cv2
import PIL
import os
import matplotlib.pyplot as plt
import tensorflow as tf
from tensorflow import keras
import warnings
warnings.filterwarnings("ignore")
# %matplotlib inline

os.listdir()

dataset_url = '/content/skin-disease-datasaet/train_set'

os.listdir(dataset_url)

dataset_url

import pathlib
data_dir=pathlib.Path(dataset_url)
data_dir

cellulitis=list(data_dir.glob('BA- cellulitis/*'))
len(cellulitis)

FU_athlete_foot=list(data_dir.glob('FU-athlete-foot/*'))
len(FU_athlete_foot)

VI_chickenpoxt=list(data_dir.glob('VI-chickenpox/*'))
len(VI_chickenpoxt)

VI_shingles=list(data_dir.glob('VI-shingles/*'))
len(VI_shingles)

FU_nail_fungus=list(data_dir.glob('FU-nail-fungus/*'))
len(FU_nail_fungus)

BA_impetigo=list(data_dir.glob('BA-impetigo/*'))
len(BA_impetigo)

FU_ringworm=list(data_dir.glob('FU-ringworm/*'))
len(FU_ringworm)

PA_cutaneous_larva_migrans=list(data_dir.glob('PA-cutaneous-larva-migrans/*'))
len(PA_cutaneous_larva_migrans)

"""**Data Loading**"""

train_dir = '/content/skin-disease-datasaet/train_set'
test_dir = '/content/skin-disease-datasaet/test_set'

total_train_images = 0
total_test_images = 0

for category in os.listdir(train_dir):
    category_dir = os.path.join(train_dir, category)
    num_images = len(os.listdir(category_dir))
    print(f"Train - {category}: {num_images} images")
    total_train_images += num_images

for category in os.listdir(test_dir):
    category_dir = os.path.join(test_dir, category)
    num_images = len(os.listdir(category_dir))
    print(f"Test - {category}: {num_images} images")
    total_test_images += num_images

print(f"Total train images: {total_train_images}")
print(f"Total test images: {total_test_images}")

"""**Visualizations in training set**"""

import seaborn as sns

classes =os.listdir('/content/skin-disease-datasaet/train_set')
classes = sorted(classes)
classes

import pathlib
import random
import cv2
import matplotlib.pyplot as plt
import os
from pathlib import Path

NUM_IMAGES = 4

fig, ax = plt.subplots(nrows = len(classes), ncols = NUM_IMAGES, figsize = (9, 20))

p = 0

for c in classes:

    img_path_class = list(Path(os.path.join(train_dir,c)).glob("*.jpg"))
    img_selected = random.choices(img_path_class, k = NUM_IMAGES)
    for i,j in enumerate(img_selected):
        img_bgr = cv2.imread(str(j))
        img_rgb = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2RGB)
        ax[p,i].imshow(img_rgb)
        ax[p,i].set_title(f"Class: {c}\nShape: {img_rgb.shape}")
        ax[p,i].axis('off')

    p += 1

fig.tight_layout()
fig.show()

classes = os.listdir("/content/skin-disease-datasaet/test_set")
classes = sorted(classes)

import pathlib
import random
import cv2
import matplotlib.pyplot as plt
import os
from pathlib import Path
NUM_IMAGES = 4

fig, ax = plt.subplots(nrows = len(classes), ncols = NUM_IMAGES, figsize = (10, 20))

p = 0

for c in classes:
    img_path_class = list(Path(os.path.join(test_dir,c)).glob("*.jpg"))
    img_selected = random.choices(img_path_class, k = NUM_IMAGES)
    for i,j in enumerate(img_selected):
        img_bgr = cv2.imread(str(j))
        img_rgb = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2RGB)
        ax[p,i].imshow(img_rgb)
        ax[p,i].set_title(f"Class: {c}\nShape: {img_rgb.shape}")
        ax[p,i].axis('off')

    p += 1

fig.tight_layout()
fig.show()

print(pd.Series(root_labels).value_counts())
plt.figure(figsize=(9, 3))
sns.countplot(y=pd.Series(root_labels))
plt.title("\nThe number of images on each labels\n", weight="bold")
plt.xlabel("")

n_clusters=2

random.seed(42)
batch = [random.choices(data_dict[lab], k=1)[0] for lab in data_dict]

for i, img in enumerate(batch):

    w, h, channel = img.shape
    X = np.reshape(img, (w * h, channel))

    # Kmeans clustering with 3 clusters
    kmeans = KMeans(n_clusters, random_state=0, n_init='auto').fit(X)

    pred_label = kmeans.predict(X)
    pred_label = np.reshape(pred_label, (h, w))
    mask = np.zeros(shape=(h, w, channel))
    mask_colors = [
        (0.0, 0.0, 0.0),
        (0.5, 0.5, 0.5),
        (1.0, 1.0, 1.0),
    ]

    # Display image clustering
    fg, ax = plt.subplots(1, 2, figsize = (15, 5))

    ax[0].imshow(img / 255.0)
    ax[0].set_title(f"{classes[i]}")
    ax[0].axis('off')

    for i in range(n_clusters):
        mask[pred_label == i] = mask_colors[i % len(mask_colors)]

    mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, np.ones((3, 3), np.uint8), iterations=2)
    ax[1].imshow(mask)
    ax[1].set_title(f'Segmented Mask')
    ax[1].axis('off')

import numpy as np
import cv2
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans
import random

# Debugging: Ensure data_dict is valid
assert data_dict, "Error: data_dict is empty!"

# Parameters
n_clusters = 2
random.seed(42)
batch = [random.choices(data_dict[lab], k=1)[0] for lab in data_dict]

# Iterate over the batch
for i, img in enumerate(batch):
    # Ensure image has valid shape
    if len(img.shape) != 3:
        raise ValueError(f"Invalid image shape: {img.shape}")

    w, h, channel = img.shape
    X = np.reshape(img, (w * h, channel))

    # KMeans clustering
    kmeans = KMeans(n_clusters, random_state=0, n_init='auto').fit(X)
    pred_label = kmeans.predict(X)
    pred_label = np.reshape(pred_label, (h, w))

    # Initialize mask
    mask = np.zeros(shape=(h, w, channel))
    mask_colors = [(np.random.random(), np.random.random(), np.random.random()) for _ in range(n_clusters)]

    # Populate mask
    for cluster_idx in range(n_clusters):
        mask[pred_label == cluster_idx] = mask_colors[cluster_idx]

    # Apply morphological operations
    mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, np.ones((3, 3), np.uint8), iterations=2)

    # Plot images
    fg, ax = plt.subplots(1, 2, figsize=(15, 5))
    ax[0].imshow(img / 255.0)
    ax[0].set_title(f"Original Image")
    ax[0].axis('off')

    ax[1].imshow(mask)
    ax[1].set_title(f'Segmented Mask')
    ax[1].axis('off')

    # Ensure the plot renders
    plt.show()

